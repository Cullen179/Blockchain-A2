generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model Blockchain {
  id         String @id @default(cuid())
  difficulty Int    @default(4) @map("difficulty")
  createdAt  DateTime @default(now()) @map("created_at")
  updatedAt  DateTime @updatedAt @map("updated_at")

  // Relations
  blocks Block[]

  @@map("blockchain")
}

model Block {
  hash          String   @id
  index         Int      @unique
  previousHash  String   @map("previous_hash")
  merkleRoot    String   @map("merkle_root")
  timestamp     Int
  nonce         Int
  size          Int      @default(0)
  blockchainId  String?  @map("blockchain_id") // Optional reference to blockchain
  createdAt     DateTime @default(now()) @map("created_at")

  // Relations
  blockchain   Blockchain?   @relation(fields: [blockchainId], references: [id])
  transactions Transaction[]

  @@map("blocks")
}

model Transaction {
  id        String   @id
  from      String   
  to        String   
  amount    Int      
  fee       Int      
  timestamp BigInt   
  size      Int      @default(0)
  blockHash String?  @map("block_hash")
  mempoolId String?  @map("mempool_id") // Reference to mempool
  createdAt DateTime @default(now()) @map("created_at")

  // Relations
  block   Block?              @relation(fields: [blockHash], references: [hash])
  inputs  TransactionInput[]
  outputs TransactionOutput[]
  utxos   UTXO[]
  mempool Mempool?            @relation(fields: [mempoolId], references: [id])
  
  @@map("transactions")
}

model TransactionInput {
  id                    Int      @id @default(autoincrement())
  transactionId         String   @map("transaction_id")
  previousTransactionId String   @map("previous_transaction_id")
  outputIndex           Int      @map("output_index")
  scriptSig             String   @map("script_sig") // Changed from signature to scriptSig
  createdAt             DateTime @default(now()) @map("created_at")

  // Relations
  transaction Transaction @relation(fields: [transactionId], references: [id])

  @@map("transaction_inputs")
}

model TransactionOutput {
  id           Int      @id @default(autoincrement())
  transactionId String  @map("transaction_id")
  address       String
  amount        Int     // Changed from Float to Int
  scriptPubKey  String  @map("script_pub_key")
  createdAt     DateTime @default(now()) @map("created_at")

  // Relations
  transaction Transaction @relation(fields: [transactionId], references: [id])

  @@map("transaction_outputs")
}

model UTXO {
  id            String    @id
  transactionId String    @map("transaction_id")
  outputIndex   Int       @map("output_index")
  address       String
  amount        Int       // Changed from Float to Int
  scriptPubKey  String    @map("script_pub_key")
  isSpent       Boolean   @default(false) @map("is_spent")
  spentAt       DateTime? @map("spent_at") // Added optional spentAt field
  createdAt     DateTime  @default(now()) @map("created_at")

  // Relations
  transaction Transaction @relation(fields: [transactionId], references: [id])
  wallet      Wallet?     @relation(fields: [address], references: [address])
  
  @@unique([transactionId, outputIndex])
  @@map("utxos")
}

model Wallet {
  address    String   @id
  privateKey String   @map("private_key")
  publicKey  String   @map("public_key")
  balance    Int      @default(0)
  
  // Relations
  utxos UTXO[]

  @@map("wallets")
}

model Mempool {
  id          String        @id @default(cuid())
  maxSize     Int           @default(1000) // Maximum number of transactions in the mempool
  currentSize Int           @default(0) 
  createdAt   DateTime      @default(now()) @map("created_at")
  updatedAt   DateTime      @updatedAt @map("updated_at")
  
  // Relations
  transactions Transaction[]
  
  @@map("mempools")
}